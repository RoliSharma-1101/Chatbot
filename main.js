// DOM Elements
const chatlogs = document.getElementById("chatlogs");
const userInput = document.getElementById("userInput");
const sendBtn = document.getElementById("sendBtn");
const micBtn = document.getElementById("micBtn");

// Debug logging for initialization
console.log('Chat elements initialization:', {
  chatlogs: !!chatlogs,
  userInput: !!userInput,
  sendBtn: !!sendBtn,
  micBtn: !!micBtn
});

// Check if DOM elements exist
if (!chatlogs || !userInput || !sendBtn) {
  console.error("Required DOM elements not found");
  throw new Error("Required DOM elements not found");
}

// State management
let currentStep = "language_selection";
let language = "en";
let userPhone = null;
let userName = "User";
let userIntent = null; // 'lodge' or 'status' or 'profile'
let complaintData = {
  category: null,
  details: null,
  full_name: null,
  industrial_area: null
};
let currentComplaintId = "";
let uploadedFiles = []; // Track uploaded files
let token = null; // Store JWT after OTP verification
// Add global timer variables
let otpTimer = null;
let otpTimeLeft = 60;
// Set API base URL for backend
// const API_BASE = "http://localhost:3000";
const API_BASE = "https://compl-reg-api.onrender.com";
// Language-specific messages
const messages = {
  en: {
    welcome: "ЁЯСЛHi there ! Welcome to the Grievance Redressal System!<br>I am the UPSIDA AI Assistant, here to help with your grievances.",
    selectLanguage: "ЁЯМР To get started, please select your language by typing 'English' or 'Hindi'.",
    greeting: "ЁЯСЛ Hello! How can I help you today?",
    lodgeComplaint: "ЁЯУЭ Lodge a New Complaint",
    checkStatus: "ЁЯУК Check Complaint Status",
    enterMobile: "ЁЯУ▒ To proceed, I need to verify your identity. Please enter your 10-digit mobile number.",
    invalidMobile: "тЭМ Invalid number. Please enter a 10-digit mobile number.",
    otpSent: "тЬЕ Thank you. I've sent a 6-digit OTP to your number. Please enter it here.",
    invalidOTP: "тЭМ Incorrect OTP. Please try again.",
    welcomeBack: "ЁЯСЛ Welcome, {name}. Let's file your complaint. Please select the category of your issue.",
    selectCategory: "ЁЯСЗ Please select the category of your issue.",
    describeProblem: "тЬНя╕П Understood. The complaint is about {category}. Could you please describe the problem in detail for me?",
    uploadPhoto: "ЁЯЦ╝я╕П Thank you for the details. A picture is often very helpful. If you have a photo of the issue, please use the upload button.",
    uploadFile: "ЁЯУО Upload File",
    skip: "тЮбя╕П Skip",
    complaintSubmitted: "тЬЕ Thank you, {name}. Your complaint has been submitted successfully.",
    complaintId: "ЁЯЖФ Your Reference ID is: {id}",
    updatesInfo: "ЁЯФФ You will receive updates via SMS and can also check the status here anytime. Can I help with anything else?",
    checkAnotherStatus: "ЁЯУК Check Another Status",
    endChat: "ЁЯТм End Chat",
    enterComplaintId: "ЁЯЖФ Sure. Please enter your Complaint ID to get the status.",
    statusFor: "ЁЯУД Here is the status for complaint {id}:",
    status: "ЁЯУК Status: {status}",
    complaintCategory: "ЁЯУБ Category: {category}",
    complaintDetails: "ЁЯУЭ Details: {details}",
    lastUpdate: "ЁЯХТ Last Update: {update}",
    anythingElse: "ЁЯдФ Is there anything else I can assist you with?",
    lodgeAnother: "ЁЯУЭ Lodge a New Complaint",
    checkAnotherId: "ЁЯЖФ Check Another ID",
    fallback: "ЁЯдЦ I'm sorry, I'm not equipped to handle that request right now. Please choose one of the options below, or if you need to speak to a person, please contact the UPSIDA helpdesk at 1800-XXX-XXXX.",
    humanHandoff: "ЁЯУЮ If you need to speak with a human agent, please call the UPSIDA helpline at 1800-XXX-XXXX during office hours (10 AM - 5 PM, Mon-Fri).",
    fileUploaded: "тЬЕ File uploaded successfully.",
    noFileUploaded: "тЭМ No file uploaded.",
    updateProfile: "ЁЯСд Update Profile",
    enterName: "ЁЯСд Please enter your full name:",
    enterIndustrialArea: "ЁЯУН Please enter your industrial area name:",
    profileUpdated: "тЬЕ Profile updated successfully!",
    profileUpdateError: "тЭМ Failed to update profile. Please try again.",
    invalidName: "тЭМ Please enter a valid name (minimum 2 characters).",
    invalidIndustrialArea: "тЭМ Please enter a valid industrial area name.",
    nameRecorded: "тЬЕ Thank you. Your full name is recorded as '{name}'.",
    tryAgain: "ЁЯФД Try Again",
    backToMenu: "тЖйя╕П Back to Main Menu"
  },
  hi: {
    welcome: "ЁЯСЛ рд╢рд┐рдХрд╛рдпрдд рдирд┐рд╡рд╛рд░рдг рдкреНрд░рдгрд╛рд▓реА рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ!<br>рдореИрдВ рдпреВрдкреАрд╕реАрдбрд╛ рдПрдЖрдИ рд╕рд╣рд╛рдпрдХ рд╣реВрдВ, рдЬреЛ рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрддреЛрдВ рдореЗрдВ рдорджрдж рдХреЗ рд▓рд┐рдП рдпрд╣рд╛рдВ рд╣реИред",
    selectLanguage: "ЁЯМР рдЖрд░рдВрдн рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП, рдХреГрдкрдпрд╛ 'English' рдпрд╛ 'Hindi' рдЯрд╛рдЗрдк рдХрд░рдХреЗ рдЕрдкрдиреА рднрд╛рд╖рд╛ рдЪреБрдиреЗрдВред",
    greeting: "ЁЯСЛ рдирдорд╕реНрддреЗ! рдореИрдВ рдпреВрдкреАрд╕реАрдбрд╛ рд╕рд╣рд╛рдпрдХ рд╣реВрдБред рдЖрдк рдХреНрдпрд╛ рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?",
    lodgeComplaint: "ЁЯУЭ рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ рдХрд░реЗрдВ",
    checkStatus: "ЁЯУК рд╢рд┐рдХрд╛рдпрдд рд╕реНрдерд┐рддрд┐ рдЬрд╛рдВрдЪреЗрдВ",
    enterMobile: "ЁЯУ▒ рдЖрдЧреЗ рдмрдврд╝рдиреЗ рдХреЗ рд▓рд┐рдП, рдореБрдЭреЗ рдЖрдкрдХреА рдкрд╣рдЪрд╛рди рд╕рддреНрдпрд╛рдкрд┐рдд рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реИред рдХреГрдкрдпрд╛ рдЕрдкрдирд╛ 10-рдЕрдВрдХреЛрдВ рдХрд╛ рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░ рджрд░реНрдЬ рдХрд░реЗрдВред",
    invalidMobile: "тЭМ рдЕрдорд╛рдиреНрдп рдирдВрдмрд░ред рдХреГрдкрдпрд╛ 10-рдЕрдВрдХреЛрдВ рдХрд╛ рдореЛрдмрд╛рдЗрд▓ рдирдВрдмрд░ рджрд░реНрдЬ рдХрд░реЗрдВред",
    otpSent: "тЬЕ рдзрдиреНрдпрд╡рд╛рджред рдЖрдкрдХреЗ рдирдВрдмрд░ рдкрд░ 6-рдЕрдВрдХреЛрдВ рдХрд╛ рдУрдЯреАрдкреА рднреЗрдЬрд╛ рдЧрдпрд╛ рд╣реИред рдХреГрдкрдпрд╛ рдпрд╣рд╛рдБ рджрд░реНрдЬ рдХрд░реЗрдВред",
    invalidOTP: "тЭМ рдЧрд▓рдд рдУрдЯреАрдкреАред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    welcomeBack: "ЁЯСЛ рдореИрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рдХрд░рддрд╛ рд╣реВрдВ, {name}ред рдЖрдЗрдП рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ рдХрд░реЗрдВред рдХреГрдкрдпрд╛ рдЕрдкрдиреА рд╕рдорд╕реНрдпрд╛ рдХреА рд╢реНрд░реЗрдгреА рдЪреБрдиреЗрдВред",
    selectCategory: "ЁЯСЗ рдХреГрдкрдпрд╛ рдЕрдкрдиреА рд╕рдорд╕реНрдпрд╛ рдХреА рд╢реНрд░реЗрдгреА рдЪреБрдиреЗрдВред",
    describeProblem: "тЬНя╕П рд╕рдордЭ рдЧрдпрд╛ред рд╢рд┐рдХрд╛рдпрдд {category} рд╕реЗ рд╕рдВрдмрдВрдзрд┐рдд рд╣реИред рдХреГрдкрдпрд╛ рд╕рдорд╕реНрдпрд╛ рдХрд╛ рд╡рд┐рд╡рд░рдг рджреЗрдВ:",
    uploadPhoto: "ЁЯЦ╝я╕П рд╡рд┐рд╡рд░рдг рдХреЗ рд▓рд┐рдП рдзрдиреНрдпрд╡рд╛рджред рддрд╕реНрд╡реАрд░ рдЕрдХреНрд╕рд░ рдмрд╣реБрдд рдорджрджрдЧрд╛рд░ рд╣реЛрддреА рд╣реИред рдпрджрд┐ рдЖрдкрдХреЗ рдкрд╛рд╕ рд╕рдорд╕реНрдпрд╛ рдХреА рдХреЛрдИ рддрд╕реНрд╡реАрд░ рд╣реИ, рддреЛ рдХреГрдкрдпрд╛ рдЕрдкрд▓реЛрдб рдмрдЯрди рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред",
    uploadFile: "ЁЯУО рдлрд╝рд╛рдЗрд▓ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВ",
    skip: "тЮбя╕П рдЫреЛрдбрд╝реЗрдВ",
    complaintSubmitted: "тЬЕ рдзрдиреНрдпрд╡рд╛рдж, {name}ред рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрдд рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рджрд░реНрдЬ рдХреА рдЧрдИ рд╣реИред",
    complaintId: "ЁЯЖФ рдЖрдкрдХрд╛ рд╕рдВрджрд░реНрдн рдЖрдИрдбреА рд╣реИ: {id}",
    updatesInfo: "ЁЯФФ рдЖрдкрдХреЛ рдПрд╕рдПрдордПрд╕ рдХреЗ рдорд╛рдзреНрдпрдо рд╕реЗ рдЕрдкрдбреЗрдЯ рдкреНрд░рд╛рдкреНрдд рд╣реЛрдВрдЧреЗ рдФрд░ рдпрд╣рд╛рдБ рднреА рд╕реНрдерд┐рддрд┐ рдЬрд╛рдВрдЪ рд╕рдХрддреЗ рд╣реИрдВред рдХреНрдпрд╛ рдореИрдВ рдХреБрдЫ рдФрд░ рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБ?",
    checkAnotherStatus: "ЁЯУК рджреВрд╕рд░реА рд╕реНрдерд┐рддрд┐ рдЬрд╛рдВрдЪреЗрдВ",
    endChat: "ЁЯТм рдЪреИрдЯ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ",
    enterComplaintId: "ЁЯЖФ рдЬрд╝рд░реВрд░ред рд╕реНрдерд┐рддрд┐ рдЬрд╛рдирдиреЗ рдХреЗ рд▓рд┐рдП рдХреГрдкрдпрд╛ рдЕрдкрдиреА рд╢рд┐рдХрд╛рдпрдд рдЖрдИрдбреА рджрд░реНрдЬ рдХрд░реЗрдВред",
    statusFor: "ЁЯУД рдпрд╣рд╛рдБ рд╢рд┐рдХрд╛рдпрдд {id} рдХреА рд╕реНрдерд┐рддрд┐ рд╣реИ:",
    status: "ЁЯУК рд╕реНрдерд┐рддрд┐: {status}",
    complaintCategory: "ЁЯУБ рд╢реНрд░реЗрдгреА: {category}",
    complaintDetails: "ЁЯУЭ рд╡рд┐рд╡рд░рдг: {details}",
    lastUpdate: "ЁЯХТ рдЕрдВрддрд┐рдо рдЕрдкрдбреЗрдЯ: {update}",
    anythingElse: "ЁЯдФ рдХреНрдпрд╛ рдореИрдВ рдХреБрдЫ рдФрд░ рд╕рд╣рд╛рдпрддрд╛ рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБ?",
    lodgeAnother: "ЁЯУЭ рдирдИ рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ рдХрд░реЗрдВ",
    checkAnotherId: "ЁЯЖФ рджреВрд╕рд░реА рдЖрдИрдбреА рдЬрд╛рдВрдЪреЗрдВ",
    fallback: "ЁЯдЦ рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рдореИрдВ рдЕрднреА рдЙрд╕ рдЕрдиреБрд░реЛрдз рдХреЛ рд╕рдВрднрд╛рд▓рдиреЗ рдХреЗ рд▓рд┐рдП рддреИрдпрд╛рд░ рдирд╣реАрдВ рд╣реВрдБред рдХреГрдкрдпрд╛ рдиреАрдЪреЗ рджрд┐рдП рдЧрдП рд╡рд┐рдХрд▓реНрдкреЛрдВ рдореЗрдВ рд╕реЗ рдПрдХ рдЪреБрдиреЗрдВ, рдпрд╛ рдпрджрд┐ рдЖрдкрдХреЛ рдХрд┐рд╕реА рд╡реНрдпрдХреНрддрд┐ рд╕реЗ рдмрд╛рдд рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реИ, рддреЛ рдХреГрдкрдпрд╛ рдпреВрдкреАрд╕реАрдбрд╛ рд╣реЗрд▓реНрдкрдбреЗрд╕реНрдХ рд╕реЗ рд╕рдВрдкрд░реНрдХ рдХрд░реЗрдВ 1800-XXX-XXXX рдкрд░ред",
    humanHandoff: "ЁЯУЮ рдпрджрд┐ рдЖрдкрдХреЛ рдорд╛рдирд╡ рдПрдЬреЗрдВрдЯ рд╕реЗ рдмрд╛рдд рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реИ, рддреЛ рдХреГрдкрдпрд╛ рдХрд╛рд░реНрдпрд╛рд▓рдп рд╕рдордп (рд╕реБрдмрд╣ 10 рдмрдЬреЗ - рд╢рд╛рдо 5 рдмрдЬреЗ, рд╕реЛрдо-рд╢реБрдХреНрд░) рдХреЗ рджреМрд░рд╛рди рдпреВрдкреАрд╕реАрдбрд╛ рд╣реЗрд▓реНрдкрд▓рд╛рдЗрди 1800-XXX-XXXX рдкрд░ рдХреЙрд▓ рдХрд░реЗрдВред",
    fileUploaded: "тЬЕ рдлрд╝рд╛рдЗрд▓ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдкрд▓реЛрдб рдХреА рдЧрдИред",
    noFileUploaded: "тЭМ рдХреЛрдИ рдлрд╝рд╛рдЗрд▓ рдЕрдкрд▓реЛрдб рдирд╣реАрдВ рдХреА рдЧрдИред",
    updateProfile: "ЁЯСд рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓ рдЕрдкрдбреЗрдЯ рдХрд░реЗрдВ",
    enterName: "ЁЯСд рдХреГрдкрдпрд╛ рдЕрдкрдирд╛ рдкреВрд░рд╛ рдирд╛рдо рджрд░реНрдЬ рдХрд░реЗрдВ:",
    enterIndustrialArea: "ЁЯУН рдХреГрдкрдпрд╛ рдЕрдкрдиреЗ рдФрджреНрдпреЛрдЧрд┐рдХ рдХреНрд╖реЗрддреНрд░ рдХрд╛ рдирд╛рдо рджрд░реНрдЬ рдХрд░реЗрдВ:",
    profileUpdated: "тЬЕ рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдкрдбреЗрдЯ рдХрд┐рдпрд╛ рдЧрдпрд╛!",
    profileUpdateError: "тЭМ рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓ рдЕрдкрдбреЗрдЯ рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    invalidName: "тЭМ рдХреГрдкрдпрд╛ рдПрдХ рд╡реИрдз рдирд╛рдо рджрд░реНрдЬ рдХрд░реЗрдВ (рдиреНрдпреВрдирддрдо 2 рдЕрдХреНрд╖рд░)ред",
    invalidIndustrialArea: "тЭМ рдХреГрдкрдпрд╛ рдПрдХ рд╡реИрдз рдФрджреНрдпреЛрдЧрд┐рдХ рдХреНрд╖реЗрддреНрд░ рдХрд╛ рдирд╛рдо рджрд░реНрдЬ рдХрд░реЗрдВред",
    nameRecorded: "тЬЕ рдзрдиреНрдпрд╡рд╛рджред рдЖрдкрдХрд╛ рдкреВрд░рд╛ рдирд╛рдо '{name}' рдХреЗ рд░реВрдк рдореЗрдВ рджрд░реНрдЬ рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред",
    tryAgain: "ЁЯФД рдлрд┐рд░ рд╕реЗ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ",
    backToMenu: "тЖйя╕П рдореБрдЦреНрдп рдореЗрдиреВ рдкрд░ рдЬрд╛рдПрдВ"
  }
};

// Add language-specific placeholder and send button text
const placeholders = {
  en: "Type your message...",
  hi: "рдЕрдкрдирд╛ рд╕рдВрджреЗрд╢ рд▓рд┐рдЦреЗрдВ..."
};
const sendBtnTexts = {
  en: "Send",
  hi: "рднреЗрдЬреЗрдВ"
};
function getMessage(key, params = {}) {
  let message = messages[language][key] || messages.en[key];
  if (!message) {
    console.error(`Message key "${key}" not found for language "${language}"`);
    return `Message not found: ${key}`;
  }
  Object.keys(params).forEach(param => {
    message = message.replace(`{${param}}`, params[param]);
  });
  return message;
}
// Helper to add animated ЁЯЩП after Namaste/рдирдорд╕реНрддреЗ
function addAnimatedNamaste(msg) {
  if (typeof msg !== 'string') return msg;
  if (msg.includes('рдирдорд╕реНрддреЗ')) {
    return msg.replace('рдирдорд╕реНрддреЗ', 'рдирдорд╕реНрддреЗ <span class="namaste-emoji1">ЁЯЩП</span>');
  }
  if (msg.includes('Namaste')) {
    return msg.replace('Namaste', 'Namaste <span class="namaste-emoji1">ЁЯЩП</span>');
  }
  return msg;
}
// Helper to return robot icon HTML with blinking eyelids
function getAnimatedRobotIcon() {
  return `
<span class="robot-inline-container">
<img src="assets/robot.png" class="robot-img-inline" alt="Robot" />
</span>
`;
}
// Add typing indicator before each bot message
function showTypingIndicator() {
  const typingDiv = document.createElement("div");
  typingDiv.className = "typing-indicator";
  typingDiv.id = "typing-indicator";
  typingDiv.innerHTML = '<span></span><span></span><span></span>';
  chatlogs.appendChild(typingDiv);
  chatlogs.scrollTop = chatlogs.scrollHeight;
}
function removeTypingIndicator() {
  const typingDiv = document.getElementById("typing-indicator");
  if (typingDiv) typingDiv.remove();
}
// Update showBotMessages to include icon and timestamp
async function showBotMessages(messageArray) {
  console.log("Showing bot messages:", messageArray);

  if (!chatlogs) {
    console.error("Chatlogs element not found");
    return;
  }

  for (let msg of messageArray) {
    showTypingIndicator();
    await new Promise(resolve => setTimeout(resolve, 700));
    removeTypingIndicator();

    const div = document.createElement("div");
    div.className = "chat bot";
    const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    div.innerHTML = `
      <div class="message-meta">
        <span class="message-icon"><img src="assets/favicon-32x32.png" alt="UPSIDA" style="width: 20px; height: 20px; vertical-align: middle;"></span>
        <span class="message-timestamp">${time}</span>
      </div>
      <div class="message-content">
        <span>${msg}</span>
      </div>
    `;

    chatlogs.appendChild(div);
    chatlogs.scrollTop = chatlogs.scrollHeight;
    await new Promise(resolve => setTimeout(resolve, 500));
  }
}
// Update showOptions to NOT show bot-meta (icon + name)
async function showOptions(options) {
  if (!chatlogs) {
    console.error("Chatlogs element not found in showOptions");
    return;
  }

  console.log("Showing options:", options);

  showTypingIndicator();
  await new Promise(resolve => setTimeout(resolve, 700));
  removeTypingIndicator();

  const optionsContainer = document.createElement("div");
  optionsContainer.className = "topic-buttons";

  options.forEach(opt => {
    const btn = document.createElement("button");
    btn.className = "option-btn";
    btn.innerText = opt;

    // Add hover effect class
    btn.addEventListener('mouseover', () => btn.classList.add('hover'));
    btn.addEventListener('mouseout', () => btn.classList.remove('hover'));

    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      console.log("Option selected:", opt);
      showUserMessage(opt);
      handleUserSelection(opt);
    });

    optionsContainer.appendChild(btn);
  });

  chatlogs.appendChild(optionsContainer);
  chatlogs.scrollTop = chatlogs.scrollHeight;
}
function showUserMessage(message) {
  console.log("Showing user message:", message);

  if (!chatlogs) {
    console.error("Chatlogs element not found");
    return;
  }

  const div = document.createElement("div");
  div.className = "chat user";
  const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  div.innerHTML = `
    <div class="message-meta">
        <span class="message-icon">ЁЯСд</span>
        <span class="message-timestamp">${time}</span>
    </div>
    <div class="message-content">
        <span>${message}</span>
    </div>
  `;

  chatlogs.appendChild(div);
  chatlogs.scrollTop = chatlogs.scrollHeight;
}

// Initialize chat
async function initializeChat() {
  console.log("Initializing chat...");

  try {
    // Clear chat logs
    const chatlogs = document.getElementById("chatlogs");
    if (!chatlogs) {
      throw new Error("Chatlogs element not found");
    }
    chatlogs.innerHTML = "";

    // Initialize UI
    updateInputLanguageUI();

    // Show welcome message
    await showBotMessages([getMessage("welcome")]);
    // Show language selection as clickable buttons
    await showBotMessages([getMessage("selectLanguage")]);
    await showOptions(["English", "Hindi"]);
    setStep("language_selection");
    console.log("Chat initialized, waiting for language selection");

    // Focus input field
    const userInput = document.getElementById("userInput");
    if (userInput) {
      userInput.focus();
    }
  } catch (error) {
    console.error("Error initializing chat:", error);
    const errorMessage = language === "hi"
      ? "рдЪреИрдЯ рд╢реБрд░реВ рдХрд░рдиреЗ рдореЗрдВ рд╕рдорд╕реНрдпрд╛ рд╣реБрдИред рдХреГрдкрдпрд╛ рдкреЗрдЬ рдХреЛ рд░рд┐рдлреНрд░реЗрд╢ рдХрд░реЗрдВред"
      : "Error initializing chat. Please refresh the page.";
    showBotMessages([errorMessage]);
  }
}

// Initialize chat when DOM is fully loaded
document.addEventListener('DOMContentLoaded', function () {
  console.log("DOM loaded, starting initialization");

  // First verify all required elements exist
  const requiredElements = {
    chatlogs: document.getElementById("chatlogs"),
    userInput: document.getElementById("userInput"),
    sendBtn: document.getElementById("sendBtn"),
    micBtn: document.getElementById("micBtn")
  };

  // Log element status
  console.log("Required elements status:", {
    chatlogs: !!requiredElements.chatlogs,
    userInput: !!requiredElements.userInput,
    sendBtn: !!requiredElements.sendBtn,
    micBtn: !!requiredElements.micBtn
  });

  // Check if any required elements are missing
  const missingElements = Object.entries(requiredElements)
    .filter(([key, element]) => !element)
    .map(([key]) => key);

  if (missingElements.length > 0) {
    console.error("Missing required elements:", missingElements);
    return;
  }

  // Set up event listeners
  requiredElements.sendBtn.addEventListener('click', function (e) {
    e.preventDefault();
    console.log("Send button clicked");
    sendMessage();
  });

  requiredElements.userInput.addEventListener('keydown', function (e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      console.log("Enter key pressed");
      sendMessage();
    }
  });

  // Initialize chat
  initializeChat().catch(error => {
    console.error("Failed to initialize chat:", error);
  });
});

// Function to send message
function sendMessage() {
  console.log("sendMessage called");

  const userInput = document.getElementById("userInput");
  if (!userInput) {
    console.error("userInput element not found");
    return;
  }

  const msg = userInput.value.trim();
  console.log("Message to send:", msg, "Current step:", currentStep);

  if (!msg) {
    console.log("Empty message, ignoring");
    return;
  }

  // Show user message in chat
  showUserMessage(msg);

  // Clear input field
  userInput.value = "";

  // Handle the message
  handleUserInput(msg).catch(error => {
    console.error("Error handling user input:", error);
    showBotMessages([
      language === "hi"
        ? "рдХреНрд╖рдорд╛ рдХрд░реЗрдВ, рдПрдХ рддреНрд░реБрдЯрд┐ рд╣реБрдИред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред"
        : "Sorry, an error occurred. Please try again."
    ]);
  });

  // Focus back on input
  userInput.focus();
}

// Make sendMessage available globally
window.sendMessage = sendMessage;

function generateComplaintId() {
  const d = new Date();
  const year = d.getFullYear().toString().slice(-2);
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const day = d.getDate().toString().padStart(2, '0');
  const hours = d.getHours().toString().padStart(2, '0');
  const mins = d.getMinutes().toString().padStart(2, '0');
  const secs = d.getSeconds().toString().padStart(2, '0');
  const random = Math.floor(Math.random() * 900) + 100; // 3-digit random number
  return `UPSIDA-${year}${month}${day}-${hours}${mins}${secs}-${random}`;
}

async function handleUserSelection(selection) {
  // Global command check for ending chat - Enhanced with more variations
  if (isEndChatCommand(selection)) {
    await showBotMessages([getMessage("humanHandoff")]);
    setStep("end");
    return; // Stop further processing
  }

  switch (currentStep) {
    case "language_selection":
      const normalizedInput = selection.toLowerCase().trim();
      if (normalizedInput === "english" || normalizedInput.includes("english")) {
        language = "en";
        updateInputLanguageUI();
        await showBotMessages([getMessage("greeting")]);
        await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus")]);
        setStep("main_menu");
      } else if (normalizedInput === "hindi" || normalizedInput.includes("hindi") || normalizedInput.includes("рд╣рд┐рдВрджреА")) {
        language = "hi";
        updateInputLanguageUI();
        await showBotMessages([getMessage("greeting")]);
        await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus")]);
        setStep("main_menu");
      } else {
        await showBotMessages([getMessage("fallback")]);
      }
      break;
    case "end":
      // Do nothing on button click when chat is over
      break;
    case "main_menu":
      const sel = selection.trim();
      if (
        sel === getMessage("lodgeComplaint").trim() ||
        sel.toLowerCase().includes("lodge") ||
        sel.includes("рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ рдХрд░реЗрдВ") ||
        (sel.includes("рд╢рд┐рдХрд╛рдпрдд") && !sel.includes("рд╕реНрдерд┐рддрд┐"))
      ) {
        userIntent = 'lodge'; // Set intent
        if (!token || !userPhone) {
          await showBotMessages([getMessage("enterMobile")]);
          setStep("mobile_input");
        } else {
          // Already verified, go to category selection directly
          await showBotMessages([getMessage("welcomeBack", { name: userName })]);
          await showOptions(language === "hi" ? ["рдмрд┐рдЬрд▓реА", "рдкрд╛рдиреА", "рд╕рдбрд╝рдХреЗрдВ", "рдХрдЪрд░рд╛", "рдЕрдиреНрдп"] : ["Electricity", "Water", "Roads", "Waste", "Other"]);
          setStep("category_selection");
        }
      } else if (
        sel === getMessage("checkStatus").trim() ||
        sel.toLowerCase().includes("check") ||
        sel.includes("рд╢рд┐рдХрд╛рдпрдд рд╕реНрдерд┐рддрд┐ рдЬрд╛рдВрдЪреЗрдВ") ||
        (sel.includes("рд╕реНрдерд┐рддрд┐") && sel.includes("рд╢рд┐рдХрд╛рдпрдд")) ||
        sel.includes("рдЬрд╛рдВрдЪ")
      ) {
        userIntent = 'status'; // Set intent
        if (!token || !userPhone) {
          await showBotMessages([getMessage("enterMobile")]);
          setStep("status_mobile_input");
        } else {
          // Already verified, fetch and show complaint IDs as options
          let userId = null;
          if (typeof userName === 'object' && userName.id) {
            userId = userName.id;
          } else if (typeof window !== 'undefined' && window.localStorage && window.localStorage.getItem('upsida_user_id')) {
            userId = window.localStorage.getItem('upsida_user_id');
          }
          if (userId) {
            const complaintsList = await getUserComplaintIdsApi(token, userId);
            if (complaintsList.success && complaintsList.complaintIds && complaintsList.complaintIds.length > 0) {
              await showBotMessages([
                language === "hi"
                  ? "рдпрд╣ рд░рд╣реА рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрддреЗрдВ, рдХреГрдкрдпрд╛ рдПрдХ Complaint ID рдЪреБрдиреЗрдВ рдЬрд┐рд╕рдХреА рд╕реНрдерд┐рддрд┐ рджреЗрдЦрдиреА рд╣реИ:"
                  : "Here are your complaints, please select a Complaint ID to check the status:"
              ]);
              await showOptions(complaintsList.complaintIds);
              setStep("select_complaint_id");
            } else {
              await showBotMessages([
                language === "hi"
                  ? "рдХреЛрдИ рд╢рд┐рдХрд╛рдпрдд рдирд╣реАрдВ рдорд┐рд▓реАред"
                  : "No complaints found."
              ]);
              setStep("main_menu");
            }
          } else {
            await showBotMessages([
              language === "hi"
                ? "рдпреВрдЬрд╝рд░ рдЖрдИрдбреА рдирд╣реАрдВ рдорд┐рд▓реА, рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВред"
                : "User ID not found, please login again."
            ]);
            setStep("main_menu");
          }
        }
      } else if (
        sel === getMessage("updateProfile").trim() ||
        sel.toLowerCase().includes("update") ||
        sel.toLowerCase().includes("profile") ||
        sel.includes("рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓") ||
        sel.includes("рдЕрдкрдбреЗрдЯ")
      ) {
        userIntent = 'profile'; // Set intent
        if (!token || !userPhone) {
          await showBotMessages([getMessage("enterMobile")]);
          setStep("profile_mobile_input");
        } else {
          // Already verified, go to profile name input directly
          complaintData.full_name = null; // Reset name before asking
          await showBotMessages([getMessage("enterName")]);
          setStep("profile_name_input");
        }
      } else {
        await showBotMessages([getMessage("fallback")]);
      }
      break;
    case "status_mobile_input":
      if (/^\d{10}$/.test(selection)) {
        userPhone = selection;
        // Call API to send OTP
        const result = await sendOTPApi(userPhone);
        if (result.success) {
          await showOtpInputWithTimer();
          setStep("status_otp_input");
        } else {
          await showBotMessages([result.message || getMessage("invalidMobile")]);
        }
      } else {
        await showBotMessages([getMessage("invalidMobile")]);
      }
      break;
    case "status_otp_input":
      const otpResultStatus = await verifyOTPApi(userPhone, selection);
      if (otpResultStatus.success) {
        hideOtpTimerUI();
        token = otpResultStatus.token;
        localStorage.setItem('upsida_jwt', token);
        userName = otpResultStatus.user && otpResultStatus.user.full_name ? otpResultStatus.user.full_name : "User";
        if (otpResultStatus.user && otpResultStatus.user.id) {
          localStorage.setItem('upsida_user_id', otpResultStatus.user.id);
        }
        let userId = null;
        if (otpResultStatus.user && otpResultStatus.user.id) {
          userId = otpResultStatus.user.id;
        } else if (typeof userName === 'object' && userName.id) {
          userId = userName.id;
        } else if (typeof window !== 'undefined' && window.localStorage && window.localStorage.getItem('upsida_user_id')) {
          userId = window.localStorage.getItem('upsida_user_id');
        }
        if (userId) {
          const complaintsList = await getUserComplaintIdsApi(token, userId);
          if (complaintsList.success && complaintsList.complaintIds && complaintsList.complaintIds.length > 0) {
            await showBotMessages([
              language === "hi"
                ? "рдпрд╣ рд░рд╣реА рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрддреЗрдВ, рдХреГрдкрдпрд╛ рдПрдХ Complaint ID рдЪреБрдиреЗрдВ рдЬрд┐рд╕рдХреА рд╕реНрдерд┐рддрд┐ рджреЗрдЦрдиреА рд╣реИ:"
                : "Here are your complaints, please select a Complaint ID to check the status:"
            ]);
            await showOptions(complaintsList.complaintIds);
            setStep("select_complaint_id");
          } else {
            await showBotMessages([
              language === "hi"
                ? "рдХреЛрдИ рд╢рд┐рдХрд╛рдпрдд рдирд╣реАрдВ рдорд┐рд▓реАред"
                : "No complaints found."
            ]);
            setStep("main_menu");
          }
        } else {
          await showBotMessages([
            language === "hi"
              ? "рдпреВрдЬрд╝рд░ рдЖрдИрдбреА рдирд╣реАрдВ рдорд┐рд▓реА, рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВред"
              : "User ID not found, please login again."
          ]);
          setStep("main_menu");
        }
      } else {
        await showBotMessages([otpResultStatus.message || getMessage("invalidOTP")]);
      }
      break;
    case "category_selection":
      complaintData.category = selection;
      await showBotMessages([getMessage("describeProblem", { category: selection })]);
      setStep("problem_description");
      break;
    case "file_upload":
      const userInput = selection.toLowerCase().trim();
      if (userInput.includes("skip") || userInput.includes("рдЫреЛрдбрд╝реЗрдВ")) {
        await submitComplaint();
      } else if (userInput.includes("upload") || userInput.includes("рдЕрдкрд▓реЛрдб")) {
        showFileUploadInterface();
      } else {
        await showBotMessages([getMessage("fallback")]);
      }
      break;
    case "complaint_error":
      if (selection.toLowerCase().includes(getMessage("tryAgain").toLowerCase()) || selection.toLowerCase().includes("рдХреЛрд╢рд┐рд╢") || selection.toLowerCase().includes("рдлрд┐рд░")) {
        await submitComplaint();
      } else if (selection.toLowerCase().includes(getMessage("backToMenu").toLowerCase()) || selection.toLowerCase().includes("рдореБрдЦреНрдп") || selection.toLowerCase().includes("рд╡рд╛рдкрд╕")) {
        await showBotMessages([getMessage("greeting")]);
        await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus")]);
        setStep("main_menu");
      } else {
        await showBotMessages([getMessage("fallback")]);
      }
      break;
    case "complaint_submitted":
      if (selection === getMessage("lodgeAnother")) {
        await handleComplaintLodging();
      } else if (selection === getMessage("checkAnotherId")) {
        // Remove manual complaint ID input - will use handleStatusCheck instead
        await handleStatusCheck(true);
      } else if (selection === getMessage("endChat")) {
        await showBotMessages([getMessage("humanHandoff")]);
        setStep("end");
      } else {
        await showBotMessages([getMessage("fallback")]);
      }
      break;
    case "status_checked":
      if (selection === getMessage("lodgeAnother")) {
        await handleComplaintLodging();
      } else if (selection === getMessage("checkAnotherStatus")) {
        await handleStatusCheck(true);
      } else if (selection === getMessage("endChat")) {
        await showBotMessages([getMessage("humanHandoff")]);
        setStep("end");
      } else {
        await showBotMessages([getMessage("fallback")]);
      }
      break;
    case "profile_mobile_input":
      if (/^\d{10}$/.test(selection)) {
        userPhone = selection;
        // Call API to send OTP
        const result = await sendOTPApi(userPhone);
        if (result.success) {
          await showOtpInputWithTimer();
          setStep("profile_otp_input");
        } else {
          await showBotMessages([result.message || getMessage("invalidMobile")]);
        }
      } else {
        await showBotMessages([getMessage("invalidMobile")]);
      }
      break;
    case "profile_otp_input":
      const otpResultProfile = await verifyOTPApi(userPhone, selection);
      if (otpResultProfile.success) {
        hideOtpTimerUI();
        token = otpResultProfile.token;
        localStorage.setItem('upsida_jwt', token);
        userName = otpResultProfile.user && otpResultProfile.user.full_name ? otpResultProfile.user.full_name : "User";
        await showBotMessages([getMessage("enterName")]);
        setStep("profile_name_input");
      } else {
        await showBotMessages([otpResultProfile.message || getMessage("invalidOTP")]);
      }
      break;
    case "profile_name_input":
      console.log("Processing name input:", selection);
      if (selection.trim().length >= 2) {
        // Append the new name part
        if (!complaintData.full_name) complaintData.full_name = "";
        complaintData.full_name = (complaintData.full_name + " " + selection.trim()).trim();
        userName = complaintData.full_name;

        const nameParts = complaintData.full_name.split(' ').length;

        if (nameParts >= 3) {
          // Assume name is complete and proceed
          await showBotMessages([getMessage("nameRecorded", { name: userName })]);
          await showBotMessages([getMessage("enterIndustrialArea")]);
          setStep("profile_industrial_area_input");
        } else {
          // Ask for confirmation to add more
          await showBotMessages([
            language === 'hi'
              ? `рдХреНрдпрд╛ рдЖрдкрдХрд╛ рдкреВрд░рд╛ рдирд╛рдо '${userName}' рд╣реИ?`
              : `Is your full name '${userName}'?`
          ]);
          await showOptions([
            language === 'hi' ? "рд╣рд╛рдБ, рд╕рд╣реА рд╣реИ" : "Yes, that's correct",
            language === 'hi' ? "рдирд╣реАрдВ, рдФрд░ рдЬреЛрдбрд╝реЗрдВ" : "No, add more"
          ]);
          setStep("profile_name_confirmation");
        }
      } else {
        console.log("Invalid name (too short)");
        await showBotMessages([getMessage("invalidName")]);
      }
      break;
    case "profile_name_confirmation":
      const confirmationInput = selection.toLowerCase().trim();
      if (confirmationInput.includes("yes") || confirmationInput.includes("рд╣рд╛рдБ")) {
        // Name is confirmed, proceed
        await showBotMessages([getMessage("enterIndustrialArea")]);
        setStep("profile_industrial_area_input");
      } else if (confirmationInput.includes("no") || confirmationInput.includes("рдирд╣реАрдВ")) {
        // User wants to add more to the name
        await showBotMessages([
          language === 'hi'
            ? "рдареАрдХ рд╣реИ, рдХреГрдкрдпрд╛ рдЕрдкрдиреЗ рдирд╛рдо рдХрд╛ рдЕрдЧрд▓рд╛ рднрд╛рдЧ рджрд░реНрдЬ рдХрд░реЗрдВред"
            : "Okay, please enter the next part of your name."
        ]);
        setStep("profile_name_input");
      } else {
        // Re-ask if input is unclear
        await showBotMessages([
          language === 'hi'
            ? `рдХреНрдпрд╛ рдЖрдкрдХрд╛ рдкреВрд░рд╛ рдирд╛рдо '${userName}' рд╣реИ?`
            : `Is your full name '${userName}'?`
        ]);
        await showOptions([
          language === 'hi' ? "рд╣рд╛рдБ, рд╕рд╣реА рд╣реИ" : "Yes, that's correct",
          language === 'hi' ? "рдирд╣реАрдВ, рдФрд░ рдЬреЛрдбрд╝реЗрдВ" : "No, add more"
        ]);
      }
      break;
    case "profile_industrial_area_input":
      console.log("Processing industrial area input:", selection);
      if (selection.trim().length >= 2) {
        complaintData.industrial_area = selection.trim();
        console.log("Industrial area accepted:", complaintData.industrial_area);

        // Call API to update profile
        try {
          const updateResult = await updateProfileApi(token, complaintData.full_name, complaintData.industrial_area);
          if (updateResult.success) {
            await showBotMessages([getMessage("profileUpdated")]);

            // After profile update, check original intent
            if (userIntent === 'lodge') {
              await showBotMessages([getMessage("welcomeBack", { name: userName })]);
              await showOptions(
                language === "hi"
                  ? ["рдмрд┐рдЬрд▓реА", "рдкрд╛рдиреА", "рд╕рдбрд╝рдХреЗрдВ", "рдХрдЪрд░рд╛", "рдЕрдиреНрдп"]
                  : ["Electricity", "Water", "Roads", "Waste", "Other"]
              );
              setStep("category_selection");
            } else if (userIntent === 'status') {
              // Remove manual complaint ID input - will use handleStatusCheck instead
              await handleStatusCheck(true);
            } else {
              await showMainMenu(true);
            }
          } else {
            throw new Error(updateResult.message || "Profile update failed");
          }
        } catch (error) {
          console.error("Profile update error:", error);
          await showBotMessages([getMessage("profileUpdateError")]);
          await showOptions([getMessage("tryAgain"), getMessage("backToMenu")]);
          setStep("profile_error");
        }
      } else {
        console.log("Invalid industrial area (too short)");
        await showBotMessages([getMessage("invalidIndustrialArea")]);
      }
      break;
    case "problem_description":
      console.log("Processing problem description:", selection);
      if (selection.trim().length >= 10) {
        complaintData.details = selection.trim();
        console.log("Description accepted:", complaintData.details);
        await showBotMessages([getMessage("uploadPhoto")]);
        await showOptions([getMessage("uploadFile"), getMessage("skip")]);
        setStep("file_upload");
      } else {
        console.log("Description too short");
        await showBotMessages([
          language === "hi"
            ? "рдХреГрдкрдпрд╛ рд╕рдорд╕реНрдпрд╛ рдХрд╛ рд╡рд┐рд╕реНрддреГрдд рд╡рд┐рд╡рд░рдг рджреЗрдВ (рдХрдо рд╕реЗ рдХрдо 10 рдЕрдХреНрд╖рд░)"
            : "Please provide a detailed description (minimum 10 characters)"
        ]);
      }
      break;
    case "select_complaint_id":
      if (selection.trim()) {
        const complaintResult = await getComplaintDetailApi(token, selection.trim());
        if (complaintResult.success && complaintResult.data) {
          const statusInfo = [
            getMessage("statusFor", { id: selection.trim() }),
            getMessage("status", { status: complaintResult.data.status }),
            getMessage("complaintCategory", { category: complaintResult.data.category }),
            getMessage("complaintDetails", { details: complaintResult.data.details }),
            getMessage("lastUpdate", { update: complaintResult.data.lastUpdate || 'N/A' })
          ].join('<br><br>');
          await showBotMessages([statusInfo]);
          await showOptions([getMessage("checkAnotherStatus"), getMessage("lodgeAnother"), getMessage("endChat")]);
          setStep("status_checked");
        } else {
          await showBotMessages([
            language === "hi"
              ? "рд╢рд┐рдХрд╛рдпрдд рдХреА рд╕реНрдерд┐рддрд┐ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рд╕рд╣реА Complaint ID рдЪреБрдиреЗрдВред"
              : "Failed to get complaint status. Please select a valid Complaint ID."
          ]);
        }
      }
      break;
    default:
      await showBotMessages([getMessage("fallback")]);
      break;
  }
}
// API call to request OTP
async function sendOTPApi(mobileNumber) {
  try {
    const response = await fetch(`${API_BASE}/api/request-otp`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ mobile: mobileNumber })
    });
    const data = await response.json();

    // Show OTP in alert if it's returned from the API
    if (data.success && data.otp) {
      alert(`OTP sent to database: ${data.otp}`);
    }

    return data; // { success, message, userStatus, isNewUser, otp }
  } catch (err) {
    return { success: false, message: 'Network error' };
  }
}
// API call to verify OTP
async function verifyOTPApi(mobileNumber, otp) {
  try {
    const response = await fetch(`${API_BASE}/api/verify-otp`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ mobile: mobileNumber, otp })
    });
    const data = await response.json();
    return data; // { success, message, token, userStatus, isProfileComplete, user }
  } catch (err) {
    return { success: false, message: 'Network error' };
  }
}
async function handleUserInput(input) {
  console.log("Processing user input:", input, "Current step:", currentStep, "Language:", language);

  if (!input) {
    console.error("Empty input received");
    return;
  }

  // Global command check for ending chat - Enhanced with more variations
  if (isEndChatCommand(input)) {
    await showBotMessages([getMessage("humanHandoff")]);
    setStep("end");
    return; // Stop further processing
  }

  try {
    switch (currentStep) {
      case "language_selection":
      case "end":
        const normalizedInput = input.toLowerCase().trim();
        if (normalizedInput === "english" || normalizedInput.includes("english")) {
          language = "en";
          updateInputLanguageUI();
          await showBotMessages([getMessage("greeting")]);
          await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus")]);
          setStep("main_menu");
        } else if (normalizedInput === "hindi" || normalizedInput.includes("hindi") || normalizedInput.includes("рд╣рд┐рдВрджреА")) {
          language = "hi";
          updateInputLanguageUI();
          await showBotMessages([getMessage("greeting")]);
          await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus")]);
          setStep("main_menu");
        } else {
          if (currentStep === "language_selection") {
            await showBotMessages([getMessage("selectLanguage")]);
          }
        }
        break;

      case "mobile_input":
      case "status_mobile_input":
      case "profile_mobile_input":
        console.log("Processing mobile input:", input);
        if (/^\d{10}$/.test(input)) {
          userPhone = input;
          console.log("Valid mobile number received:", userPhone);
          // Call API to send OTP
          const result = await sendOTPApi(userPhone);
          if (result.success) {
            console.log("OTP sent successfully");
            await showOtpInputWithTimer();
            setStep(currentStep === "mobile_input" ? "otp_input" :
              currentStep === "status_mobile_input" ? "status_otp_input" : "profile_otp_input");
          } else {
            console.log("OTP send failed:", result.message);
            await showBotMessages([result.message || getMessage("invalidMobile")]);
          }
        } else {
          console.log("Invalid mobile number format");
          await showBotMessages([getMessage("invalidMobile")]);
        }
        break;

      case "otp_input":
      case "status_otp_input":
      case "profile_otp_input":
        console.log("Processing OTP input:", input);
        const otpResult = await verifyOTPApi(userPhone, input);
        if (otpResult.success) {
          console.log("OTP verified successfully");
          hideOtpTimerUI();
          token = otpResult.token;
          localStorage.setItem('upsida_jwt', token);
          userName = otpResult.user && otpResult.user.full_name ? otpResult.user.full_name : "User";
          // Always save user.id to localStorage if present
          if (otpResult.user && otpResult.user.id) {
            localStorage.setItem('upsida_user_id', otpResult.user.id);
          }

          // If profile is not complete, we MUST force profile creation.
          if (!otpResult.isProfileComplete) {
            complaintData.full_name = null; // Reset name before asking
            await showBotMessages([getMessage("enterName")]);
            setStep("profile_name_input");
            return; // End processing here, will resume after profile is made
          }

          // Profile is complete, proceed based on step or intent.
          if (currentStep === 'status_otp_input' || userIntent === 'status') {
            // Remove manual complaint ID input - will use handleStatusCheck instead
            await handleStatusCheck(true);
          } else if (currentStep === 'profile_otp_input' || userIntent === 'profile') {
            complaintData.full_name = null; // Reset name before asking
            await showBotMessages([getMessage("enterName")]);
            setStep("profile_name_input");
          } else if (currentStep === 'otp_input' || userIntent === 'lodge') {
            await showBotMessages([getMessage("welcomeBack", { name: userName })]);
            await showOptions(
              language === "hi"
                ? ["рдмрд┐рдЬрд▓реА", "рдкрд╛рдиреА", "рд╕рдбрд╝рдХреЗрдВ", "рдХрдЪрд░рд╛", "рдЕрдиреНрдп"]
                : ["Electricity", "Water", "Roads", "Waste", "Other"]
            );
            setStep("category_selection");
          } else {
            await showMainMenu(true); // Fallback
          }
        } else {
          console.log("OTP verification failed:", otpResult.message);
          await showBotMessages([otpResult.message || getMessage("invalidOTP")]);
        }
        break;

      case "complaint_id_input":
        console.log("Processing complaint ID input:", input);
        if (input.trim()) {
          try {
            const complaintResult = await getComplaintDetailApi(token, input.trim());
            if (complaintResult.success && complaintResult.data) {
              const statusInfo = [
                getMessage("statusFor", { id: input.trim() }),
                getMessage("status", { status: complaintResult.data.status }),
                getMessage("complaintCategory", { category: complaintResult.data.category }),
                getMessage("complaintDetails", { details: complaintResult.data.details }),
                getMessage("lastUpdate", { update: complaintResult.data.lastUpdate || 'N/A' })
              ].join('<br><br>');

              await showBotMessages([statusInfo]);
              await showOptions([getMessage("checkAnotherStatus"), getMessage("lodgeAnother"), getMessage("endChat")]);
              setStep("status_checked");
            } else {
              throw new Error(complaintResult.message || "Failed to fetch complaint status");
            }
          } catch (error) {
            console.error("Error fetching complaint status:", error);
            await showBotMessages([
              language === "hi"
                ? "рд╢рд┐рдХрд╛рдпрдд рдХреА рд╕реНрдерд┐рддрд┐ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рд╕рд╣реА рд╢рд┐рдХрд╛рдпрдд рдЖрдИрдбреА рджрд░реНрдЬ рдХрд░реЗрдВред"
                : "Failed to get complaint status. Please enter a valid complaint ID."
            ]);
          }
        } else {
          await showBotMessages([getMessage("enterComplaintId")]);
        }
        break;

      case "main_menu":
        console.log("Processing main menu selection:", input);
        const mainMenuInput = input.toLowerCase();
        if (mainMenuInput.includes(getMessage("lodgeComplaint").toLowerCase()) ||
          mainMenuInput.includes("lodge") ||
          mainMenuInput.includes("рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ")) {
          await handleComplaintLodging();
        } else if (mainMenuInput.includes(getMessage("checkStatus").toLowerCase()) ||
          mainMenuInput.includes("check") ||
          mainMenuInput.includes("рд╕реНрдерд┐рддрд┐")) {
          userIntent = 'status';
          await handleStatusCheck();
        } else if (mainMenuInput.includes(getMessage("updateProfile").toLowerCase()) ||
          mainMenuInput.includes("update") ||
          mainMenuInput.includes("profile") ||
          mainMenuInput.includes("рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓") ||
          mainMenuInput.includes("рдЕрдкрдбреЗрдЯ")) {
          userIntent = 'profile';
          // Logic for profile update via manual input
          if (!token || !userPhone) {
            await showBotMessages([getMessage("enterMobile")]);
            setStep("profile_mobile_input");
          } else {
            await showBotMessages([getMessage("enterName")]);
            setStep("profile_name_input");
          }
        } else {
          await showBotMessages([getMessage("fallback")]);
        }
        break;

      case "profile_name_input":
        console.log("Processing name input:", input);
        if (input.trim().length >= 2) {
          // Append the new name part
          if (!complaintData.full_name) complaintData.full_name = "";
          complaintData.full_name = (complaintData.full_name + " " + input.trim()).trim();
          userName = complaintData.full_name;

          const nameParts = complaintData.full_name.split(' ').length;

          if (nameParts >= 3) {
            // Assume name is complete and proceed
            await showBotMessages([getMessage("nameRecorded", { name: userName })]);
            await showBotMessages([getMessage("enterIndustrialArea")]);
            setStep("profile_industrial_area_input");
          } else {
            // Ask for confirmation to add more
            await showBotMessages([
              language === 'hi'
                ? `рдХреНрдпрд╛ рдЖрдкрдХрд╛ рдкреВрд░рд╛ рдирд╛рдо '${userName}' рд╣реИ?`
                : `Is your full name '${userName}'?`
            ]);
            await showOptions([
              language === 'hi' ? "рд╣рд╛рдБ, рд╕рд╣реА рд╣реИ" : "Yes, that's correct",
              language === 'hi' ? "рдирд╣реАрдВ, рдФрд░ рдЬреЛрдбрд╝реЗрдВ" : "No, add more"
            ]);
            setStep("profile_name_confirmation");
          }
        } else {
          console.log("Invalid name (too short)");
          await showBotMessages([getMessage("invalidName")]);
        }
        break;

      case "profile_name_confirmation":
        const confirmationInput = input.toLowerCase().trim();
        if (confirmationInput.includes("yes") || confirmationInput.includes("рд╣рд╛рдБ")) {
          // Name is confirmed, proceed
          await showBotMessages([getMessage("enterIndustrialArea")]);
          setStep("profile_industrial_area_input");
        } else if (confirmationInput.includes("no") || confirmationInput.includes("рдирд╣реАрдВ")) {
          // User wants to add more to the name
          await showBotMessages([
            language === 'hi'
              ? "рдареАрдХ рд╣реИ, рдХреГрдкрдпрд╛ рдЕрдкрдиреЗ рдирд╛рдо рдХрд╛ рдЕрдЧрд▓рд╛ рднрд╛рдЧ рджрд░реНрдЬ рдХрд░реЗрдВред"
              : "Okay, please enter the next part of your name."
          ]);
          setStep("profile_name_input");
        } else {
          // Re-ask if input is unclear
          await showBotMessages([
            language === 'hi'
              ? `рдХреНрдпрд╛ рдЖрдкрдХрд╛ рдкреВрд░рд╛ рдирд╛рдо '${userName}' рд╣реИ?`
              : `Is your full name '${userName}'?`
          ]);
          await showOptions([
            language === 'hi' ? "рд╣рд╛рдБ, рд╕рд╣реА рд╣реИ" : "Yes, that's correct",
            language === 'hi' ? "рдирд╣реАрдВ, рдФрд░ рдЬреЛрдбрд╝реЗрдВ" : "No, add more"
          ]);
        }
        break;

      case "profile_industrial_area_input":
        console.log("Processing industrial area input:", input);
        if (input.trim().length >= 2) {
          complaintData.industrial_area = input.trim();
          console.log("Industrial area accepted:", complaintData.industrial_area);

          // Call API to update profile
          try {
            const updateResult = await updateProfileApi(token, complaintData.full_name, complaintData.industrial_area);
            if (updateResult.success) {
              await showBotMessages([getMessage("profileUpdated")]);

              // After profile update, check original intent
              if (userIntent === 'lodge') {
                await showBotMessages([getMessage("welcomeBack", { name: userName })]);
                await showOptions(
                  language === "hi"
                    ? ["рдмрд┐рдЬрд▓реА", "рдкрд╛рдиреА", "рд╕рдбрд╝рдХреЗрдВ", "рдХрдЪрд░рд╛", "рдЕрдиреНрдп"]
                    : ["Electricity", "Water", "Roads", "Waste", "Other"]
                );
                setStep("category_selection");
              } else if (userIntent === 'status') {
                // Remove manual complaint ID input - will use handleStatusCheck instead
                await handleStatusCheck(true);
              } else {
                await showMainMenu(true);
              }
            } else {
              throw new Error(updateResult.message || "Profile update failed");
            }
          } catch (error) {
            console.error("Profile update error:", error);
            await showBotMessages([getMessage("profileUpdateError")]);
            await showOptions([getMessage("tryAgain"), getMessage("backToMenu")]);
            setStep("profile_error");
          }
        } else {
          console.log("Invalid industrial area (too short)");
          await showBotMessages([getMessage("invalidIndustrialArea")]);
        }
        break;

      case "category_selection":
        console.log("Processing category selection:", input);
        const validCategories = language === "hi"
          ? ["рдмрд┐рдЬрд▓реА", "рдкрд╛рдиреА", "рд╕рдбрд╝рдХреЗрдВ", "рдХрдЪрд░рд╛", "рдЕрдиреНрдп"]
          : ["Electricity", "Water", "Roads", "Waste", "Other"];

        const selectedCategory = validCategories.find(c => c.toLowerCase() === input.toLowerCase().trim());

        if (selectedCategory) {
          complaintData.category = selectedCategory;
          console.log("Category selected:", complaintData.category);
          await showBotMessages([getMessage("describeProblem", { category: selectedCategory })]);
          setStep("problem_description");
        } else {
          console.log("Invalid category selected");
          await showBotMessages([getMessage("selectCategory")]);
          await showOptions(validCategories);
        }
        break;

      case "problem_description":
        console.log("Processing problem description:", input);
        if (input.trim().length >= 10) {
          complaintData.details = input.trim();
          console.log("Description accepted:", complaintData.details);
          await showBotMessages([getMessage("uploadPhoto")]);
          await showOptions([getMessage("uploadFile"), getMessage("skip")]);
          setStep("file_upload");
        } else {
          console.log("Description too short");
          await showBotMessages([
            language === "hi"
              ? "рдХреГрдкрдпрд╛ рд╕рдорд╕реНрдпрд╛ рдХрд╛ рд╡рд┐рд╕реНрддреГрдд рд╡рд┐рд╡рд░рдг рджреЗрдВ (рдХрдо рд╕реЗ рдХрдо 10 рдЕрдХреНрд╖рд░)"
              : "Please provide a detailed description (minimum 10 characters)"
          ]);
        }
        break;

      case "status_checked":
        console.log("Processing status_checked selection:", input);
        const statusInput = input.toLowerCase().trim();
        if (statusInput.includes("lodge") || statusInput.includes("рд╢рд┐рдХрд╛рдпрдд")) {
          await handleComplaintLodging();
        } else if (statusInput.includes("check") || statusInput.includes("status") || statusInput.includes("рд╕реНрдерд┐рддрд┐")) {
          await handleStatusCheck(true);
        } else if (statusInput.includes("end") || statusInput.includes("рд╕рдорд╛рдкреНрдд")) {
          await showBotMessages([getMessage("humanHandoff")]);
          setStep("end");
        } else {
          await showBotMessages([getMessage("fallback")]);
          await showOptions([getMessage("lodgeAnother"), getMessage("checkAnotherStatus"), getMessage("endChat")]);
        }
        break;

      case "complaint_submitted":
        console.log("Processing complaint_submitted selection:", input);
        const submittedInput = input.toLowerCase().trim();
        if (submittedInput.includes("lodge") || submittedInput.includes("рд╢рд┐рдХрд╛рдпрдд")) {
          await handleComplaintLodging();
        } else if (submittedInput.includes("id") || submittedInput.includes("рдЖрдИрдбреА")) {
          // Remove manual complaint ID input - will use handleStatusCheck instead
          await handleStatusCheck(true);
        } else if (submittedInput.includes("end") || submittedInput.includes("рд╕рдорд╛рдкреНрдд")) {
          await showBotMessages([getMessage("humanHandoff")]);
          setStep("end");
        } else {
          await showBotMessages([getMessage("fallback")]);
          await showOptions([getMessage("lodgeAnother"), getMessage("checkAnotherId"), getMessage("endChat")]);
        }
        break;

      case "select_complaint_id":
        if (selection.trim()) {
          const complaintResult = await getComplaintDetailApi(token, selection.trim());
          if (complaintResult.success && complaintResult.data) {
            const statusInfo = [
              getMessage("statusFor", { id: selection.trim() }),
              getMessage("status", { status: complaintResult.data.status }),
              getMessage("complaintCategory", { category: complaintResult.data.category }),
              getMessage("complaintDetails", { details: complaintResult.data.details }),
              getMessage("lastUpdate", { update: complaintResult.data.lastUpdate || 'N/A' })
            ].join('<br><br>');
            await showBotMessages([statusInfo]);
            await showOptions([getMessage("checkAnotherStatus"), getMessage("lodgeAnother"), getMessage("endChat")]);
            setStep("status_checked");
          } else {
            await showBotMessages([
              language === "hi"
                ? "рд╢рд┐рдХрд╛рдпрдд рдХреА рд╕реНрдерд┐рддрд┐ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рд╕рд╣реА Complaint ID рдЪреБрдиреЗрдВред"
                : "Failed to get complaint status. Please select a valid Complaint ID."
            ]);
          }
        }
        break;

      default:
        console.log("Unhandled step:", currentStep);
        await showBotMessages([getMessage("fallback")]);
        break;
    }
  } catch (error) {
    console.error("Error processing user input:", error);
    await showBotMessages([
      language === "hi"
        ? "рдХреНрд╖рдорд╛ рдХрд░реЗрдВ, рдПрдХ рддреНрд░реБрдЯрд┐ рд╣реБрдИред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред"
        : "Sorry, an error occurred. Please try again."
    ]);
  }
}

function showFileUploadInterface() {
  if (!chatlogs) return;

  const div = document.createElement("div");
  div.className = "chat bot";

  const uploadArea = document.createElement("div");
  uploadArea.className = "file-upload-area";
  uploadArea.innerHTML = `
    <div class="upload-icon">ЁЯУО</div>
    <div class="upload-text">
      <strong>${language === "hi" ? "рдлрд╝рд╛рдЗрд▓ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВ" : "Upload Files"}</strong><br>
      <span>${language === "hi" ? "рдлрд╝рд╛рдЗрд▓реЗрдВ рдЦреАрдВрдЪреЗрдВ рдФрд░ рдЫреЛрдбрд╝реЗрдВ рдпрд╛ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВ" : "Drag & drop files or click to browse"}</span>
    </div>
  `;

  const uploadInput = document.createElement("input");
  uploadInput.type = "file";
  uploadInput.accept = "image/*";
  uploadInput.multiple = true;
  uploadInput.style.display = "none";
  uploadInput.onchange = (e) => handleFileUpload(e.target.files);

  uploadArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    uploadArea.classList.add("drag-over");
  });

  uploadArea.addEventListener("dragleave", (e) => {
    e.preventDefault();
    uploadArea.classList.remove("drag-over");
  });

  uploadArea.addEventListener("drop", (e) => {
    e.preventDefault();
    uploadArea.classList.remove("drag-over");
    const files = e.dataTransfer.files;
    handleFileUpload(files);
  });

  uploadArea.addEventListener("click", () => uploadInput.click());

  div.appendChild(uploadArea);
  div.appendChild(uploadInput);
  chatlogs.appendChild(div);
  chatlogs.scrollTop = chatlogs.scrollHeight;
}

async function handleFileUpload(files) {
  if (!files || files.length === 0) {
    await showBotMessages([getMessage("noFileUploaded")]);
    return;
  }

  const file = files[0];
  console.log("File selected for upload:", file.name);

  const reader = new FileReader();
  reader.onload = async (e) => {
    // Show a preview card for the selected file
    const filePreview = document.createElement("div");
    filePreview.className = "chat user";
    filePreview.innerHTML = `
            <div class="file-preview-card">
                <img src="${e.target.result}" alt="${file.name}" class="file-preview-img">
                <div class="file-info">
                    <span class="file-name">${file.name}</span>
                    <span class="file-size">${(file.size / 1024).toFixed(1)} KB</span>
                </div>
            </div>
        `;
    chatlogs.appendChild(filePreview);
    chatlogs.scrollTop = chatlogs.scrollHeight;

    // Immediately try to submit the complaint with the file.
    await submitComplaint(file);
  };
  reader.readAsDataURL(file);
}

// Create Complaint API call (with optional file)
async function createComplaintApi(token, complaintId, category, details, file) {
  const formData = new FormData();
  formData.append('complaintId', complaintId);
  formData.append('category', category);
  formData.append('details', details);
  if (file) formData.append('file', file);
  try {
    const response = await fetch(`${API_BASE}/api/complaints`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      },
      body: formData
    });
    const data = await response.json();
    return data;
  } catch (err) {
    console.error('Complaint API error:', err);
    return { success: false, message: 'Network error' };
  }
}
// Get Complaint Detail API call
async function getComplaintDetailApi(token, complaintId) {
  const response = await fetch(`${API_BASE}/api/complaints/${complaintId}`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  return await response.json();
}
// Update Profile API call
async function updateProfileApi(token, full_name, industrial_area) {
  try {
    const response = await fetch(`${API_BASE}/api/update-profile`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        full_name: full_name,
        industrial_area: industrial_area
      })
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    return { success: true, data: data };
  } catch (error) {
    console.error('Update Profile API error:', error);
    return {
      success: false,
      error: error.message || 'Network error occurred while updating profile'
    };
  }
}
// Always read token from localStorage before making API calls
if (localStorage.getItem('upsida_jwt')) {
  token = localStorage.getItem('upsida_jwt');
}
// Add this function near the top of the file
async function translateText(text, targetLang = "hi") {
  const res = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`);
  const data = await res.json();
  return data[0][0][0];
}
// Show OTP input with timer and resend button
async function showOtpInputWithTimer() {
  await showBotMessages([getMessage("otpSent")]);
  showOtpTimerUI();
  startOtpTimer();
}
// Show timer and resend button in UI
function showOtpTimerUI() {
  // Remove old timer if exists
  const oldTimer = document.getElementById("otp-timer-ui");
  if (oldTimer) oldTimer.remove();
  const div = document.createElement("div");
  div.id = "otp-timer-ui";
  div.className = "chat bot";
  div.innerHTML = `
<span id="otp-timer-label">${language === "hi" ? "рдкреБрдирдГ рднреЗрдЬрдиреЗ рдХреЗ рд▓рд┐рдП рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВ:" : "Wait to resend:"} <b id="otp-timer">${otpTimeLeft}</b>s</span>
<button id="resendOtpBtn" disabled style="margin-left:10px;">${language === "hi" ? "рдУрдЯреАрдкреА рдкреБрдирдГ рднреЗрдЬреЗрдВ" : "Resend OTP"}</button>
`;
  chatlogs.appendChild(div);
  chatlogs.scrollTop = chatlogs.scrollHeight;
  document.getElementById("resendOtpBtn").onclick = async () => {
    if (otpTimeLeft === 0) {
      const result = await sendOTPApi(userPhone);
      if (result.success) {
        removePreviousOtpSentMessages();
        await showBotMessages([getMessage("otpSent")]);
        otpTimeLeft = 30;
        showOtpTimerUI(); // Show timer UI again after bot message
        startOtpTimer();
      } else {
        await showBotMessages([result.message || getMessage("invalidMobile")]);
      }
    }
  };
}
// Start or restart the OTP timer
function startOtpTimer() {
  otpTimeLeft = 30;
  updateOtpTimerUI();
  if (otpTimer) clearInterval(otpTimer);
  otpTimer = setInterval(() => {
    otpTimeLeft--;
    updateOtpTimerUI();
    if (otpTimeLeft <= 0) {
      clearInterval(otpTimer);
      const resendBtn = document.getElementById("resendOtpBtn");
      const label = document.getElementById("otp-timer-label");
      if (resendBtn) resendBtn.disabled = false;
      if (label) label.innerText = language === "hi"
        ? "рдУрдЯреАрдкреА рдирд╣реАрдВ рдорд┐рд▓рд╛? рдкреБрдирдГ рднреЗрдЬреЗрдВ:"
        : "Didn't get OTP? Resend:";
    }
  }, 1000);
}
// Update timer in UI
function updateOtpTimerUI() {
  const timerElem = document.getElementById("otp-timer");
  const resendBtn = document.getElementById("resendOtpBtn");
  if (timerElem) timerElem.innerText = otpTimeLeft;
  if (resendBtn) resendBtn.disabled = otpTimeLeft > 0;
}
// Add this function to remove the OTP timer UI and clear the timer
function hideOtpTimerUI() {
  const oldTimer = document.getElementById("otp-timer-ui");
  if (oldTimer) oldTimer.remove();
  if (otpTimer) {
    clearInterval(otpTimer);
    otpTimer = null;
  }
}
// Helper to remove all previous OTP sent messages from chatlogs
function removePreviousOtpSentMessages() {
  const chatDivs = chatlogs.querySelectorAll('.chat.bot');
  chatDivs.forEach(div => {
    if (div.innerText && (div.innerText.includes("Thank you. I've sent a 6-digit OTP") || div.innerText.includes("рдзрдиреНрдпрд╡рд╛рджред рдЖрдкрдХреЗ рдирдВрдмрд░ рдкрд░ 6-рдЕрдВрдХреЛрдВ рдХрд╛ рдУрдЯреАрдкреА рднреЗрдЬрд╛ рдЧрдпрд╛ рд╣реИ"))) {
      div.remove();
    }
  });
}
// Typing animation for input placeholder
function animatePlaceholder() {
  const input = document.getElementById('userInput');
  if (!input) return;
  // Stop any previous animation
  if (input._placeholderInterval) {
    clearTimeout(input._placeholderInterval);
    input._placeholderInterval = null;
  }
  const text = placeholders[language] || placeholders.en;
  let i = 0;
  let isAdding = true;
  function run() {
    input.setAttribute('placeholder', text.slice(0, i));
    if (isAdding) {
      if (i < text.length) {
        i++;
        input._placeholderInterval = setTimeout(run, 90);
      } else {
        isAdding = false;
        input._placeholderInterval = setTimeout(run, 1200); // Pause when full
      }
    } else {
      if (i > 0) {
        i--;
        input._placeholderInterval = setTimeout(run, 40);
      } else {
        isAdding = true;
        input._placeholderInterval = setTimeout(run, 400); // Pause before typing again
      }
    }
  }
  run();
}
// Add this function to dynamically update input maxlength
function updateInputMaxLength(maxLength) {
  const input = document.getElementById('userInput');
  if (input) {
    if (maxLength) {
      input.setAttribute('maxlength', maxLength);
    } else {
      input.removeAttribute('maxlength');
    }
  }
}
// Centralized function to set current step and update UI accordingly
function setStep(newStep) {
  currentStep = newStep;
  switch (newStep) {
    case 'mobile_input':
    case 'status_mobile_input':
    case 'profile_mobile_input':
      updateInputMaxLength(10);
      break;
    case 'otp_input':
    case 'status_otp_input':
    case 'profile_otp_input':
      updateInputMaxLength(6);
      break;
    default:
      updateInputMaxLength(null); // Remove maxlength for other steps
      break;
  }
}
// Helper function to show main menu with appropriate options
async function showMainMenu(showProfileOption = true) {
  await showBotMessages([getMessage("greeting")]);
  if (showProfileOption) {
    await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus"), getMessage("updateProfile")]);
  } else {
    await showOptions([getMessage("lodgeComplaint"), getMessage("checkStatus")]);
  }
  setStep("main_menu");
}
// Add this function to update the placeholder and Send button text dynamically based on language selection
function updateInputLanguageUI() {
  const input = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');
  if (input) input.setAttribute('placeholder', placeholders[language] || placeholders.en);
  if (sendBtn) sendBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
  // Restart placeholder animation
  animatePlaceholder();
}
// Helper for speech UI
const waveformContainer = document.getElementById('waveform-container');

function generateWaveform() {
  if (!waveformContainer) return;
  waveformContainer.innerHTML = '';
  const bars = 25; // Adjusted for a smaller container
  for (let i = 0; i < bars; i++) {
    const bar = document.createElement('div');
    bar.className = 'wave-bar';
    // Set a random height for each bar to create a dynamic look
    bar.style.height = `${Math.floor(Math.random() * 30) + 5}px`;
    waveformContainer.appendChild(bar);
  }
}

// Speech-to-Text (Web Speech API) integration
if (micBtn && 'webkitSpeechRecognition' in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();
  recognition.lang = language === 'hi' ? 'hi-IN' : 'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;

  micBtn.addEventListener('click', () => {
    if (micBtn.classList.contains('listening')) {
      recognition.stop();
    } else {
      recognition.lang = language === 'hi' ? 'hi-IN' : 'en-US';
      recognition.start();
    }
  });

  recognition.onstart = () => {
    micBtn.classList.add('listening');
    userInput.placeholder = language === 'hi' ? 'рд╕реБрди рд░рд╣рд╛ рд╣реИ...' : 'Listening...';
  };

  recognition.onresult = (event) => {
    let transcript = event.results[0][0].transcript;

    // For mobile number input, remove spaces to ensure validation passes.
    if (['mobile_input', 'status_mobile_input', 'profile_mobile_input'].includes(currentStep)) {
      transcript = transcript.replace(/\s+/g, '');
    }

    userInput.value = transcript;
    // Automatically send the message if there's a result
    if (transcript.trim()) {
      sendMessage();
    }
  };

  recognition.onend = () => {
    micBtn.classList.remove('listening');
    userInput.placeholder = placeholders[language];
  };

  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    micBtn.classList.remove('listening');
    userInput.placeholder = placeholders[language];
  };
} else if (micBtn) {
  micBtn.disabled = true;
  micBtn.title = 'Speech recognition not supported in this browser.';
}
// Add a helper to validate complaint data before submission
function validateComplaintData() {
  console.log('validateComplaintData called:', complaintData);
  if (!complaintData.category || !complaintData.details) {
    console.warn('Validation failed: category or details missing', complaintData);
    return false;
  }
  return true;
}
// Add a helper to submit the complaint
async function submitComplaint(file = null) {
  // Debug: log complaintData and token
  console.log('Submitting complaint with:', complaintData, 'token:', token, 'file:', file);

  // Always generate a fresh complaint ID for each submission attempt
  const complaintId = generateComplaintId();
  console.log(`Generated Complaint ID for this submission: ${complaintId}`);

  // Validate data before API call
  if (!validateComplaintData()) {
    console.error('Validation failed in submitComplaint:', complaintData);
    await showBotMessages([
      language === 'hi'
        ? 'рдХреГрдкрдпрд╛ рд╕рднреА рдЖрд╡рд╢реНрдпрдХ рдЬрд╛рдирдХрд╛рд░реА рднрд░реЗрдВ (рд╢реНрд░реЗрдгреА рдФрд░ рд╡рд┐рд╡рд░рдг)ред'
        : 'Please fill all required information (category and description).'
    ]);
    await showOptions([getMessage("tryAgain"), getMessage("backToMenu")]);
    setStep("complaint_error");
    return;
  }
  if (!token) {
    await showBotMessages([
      language === 'hi'
        ? 'рд╕рддреНрд░ рд╕рдорд╛рдкреНрдд рд╣реЛ рдЧрдпрд╛ рд╣реИред рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВред'
        : 'Session expired. Please login again.'
    ]);
    await showOptions([getMessage("backToMenu")]);
    setStep("complaint_error");
    return;
  }
  const result = await createComplaintApi(token, complaintId, complaintData.category, complaintData.details, file ? file : undefined);
  if (result.success && result.data && result.data.complaintId) {
    await showBotMessages([
      getMessage("complaintSubmitted", { name: userName }),
      getMessage("complaintId", { id: result.data.complaintId }),
      getMessage("updatesInfo")
    ]);
    await showOptions([getMessage("lodgeAnother"), getMessage("checkAnotherId"), getMessage("endChat")]);
    setStep("complaint_submitted");
  } else {
    await showBotMessages([
      result.message || (language === 'hi' ? 'рд╢рд┐рдХрд╛рдпрдд рджрд░реНрдЬ рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред' : 'Complaint submission failed. Please try again.')
    ]);
    await showOptions([getMessage("tryAgain"), getMessage("backToMenu")]);
    setStep("complaint_error");
  }
}
// Helper function to handle complaint lodging
async function handleComplaintLodging() {
  if (!token || !userPhone) {
    await showBotMessages([getMessage("enterMobile")]);
    setStep("mobile_input");
  } else {
    await showBotMessages([getMessage("welcomeBack", { name: userName })]);
    await showOptions(
      language === "hi"
        ? ["рдмрд┐рдЬрд▓реА", "рдкрд╛рдиреА", "рд╕рдбрд╝рдХреЗрдВ", "рдХрдЪрд░рд╛", "рдЕрдиреНрдп"]
        : ["Electricity", "Water", "Roads", "Waste", "Other"]
    );
    setStep("category_selection");
  }
}

// Helper function to handle status check
async function handleStatusCheck(skipMobileInput = false) {
  if (!token || !userPhone || !skipMobileInput) {
    await showBotMessages([getMessage("enterMobile")]);
    setStep("status_mobile_input");
  } else {
    // Fetch and show complaint IDs as options
    let userId = null;
    if (typeof userName === 'object' && userName.id) {
      userId = userName.id;
    } else if (typeof window !== 'undefined' && window.localStorage && window.localStorage.getItem('upsida_user_id')) {
      userId = window.localStorage.getItem('upsida_user_id');
    }
    if (userId) {
      const complaintsList = await getUserComplaintIdsApi(token, userId);
      if (complaintsList.success && complaintsList.complaintIds && complaintsList.complaintIds.length > 0) {
        await showBotMessages([
          language === "hi"
            ? "рдпрд╣ рд░рд╣реА рдЖрдкрдХреА рд╢рд┐рдХрд╛рдпрддреЗрдВ, рдХреГрдкрдпрд╛ рдПрдХ Complaint ID рдЪреБрдиреЗрдВ рдЬрд┐рд╕рдХреА рд╕реНрдерд┐рддрд┐ рджреЗрдЦрдиреА рд╣реИ:"
            : "Here are your complaints, please select a Complaint ID to check the status:"
        ]);
        await showOptions(complaintsList.complaintIds);
        setStep("select_complaint_id");
      } else {
        await showBotMessages([
          language === "hi"
            ? "рдХреЛрдИ рд╢рд┐рдХрд╛рдпрдд рдирд╣реАрдВ рдорд┐рд▓реАред"
            : "No complaints found."
        ]);
        setStep("main_menu");
      }
    } else {
      await showBotMessages([
        language === "hi"
          ? "рдпреВрдЬрд╝рд░ рдЖрдИрдбреА рдирд╣реАрдВ рдорд┐рд▓реА, рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВред"
          : "User ID not found, please login again."
      ]);
      setStep("main_menu");
    }
  }
}

// Get all complaint IDs for the logged-in user
async function getUserComplaintIdsApi(token, userId) {
  const response = await fetch(`${API_BASE}/api/complaints/user/${userId}/`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  return await response.json();
}

// Helper function to check if user wants to end chat
function isEndChatCommand(input) {
  const endChatInput = input.toLowerCase().trim();
  const endChatPhrases = [
    // English variations
    "end chat", "end", "exit", "quit", "stop", "bye", "goodbye", "close chat", "finish chat",
    "end conversation", "stop chat", "close", "terminate", "end session", "logout", "sign out",
    // Hindi variations  
    "рд╕рдорд╛рдкреНрдд", "рдмрдВрдж рдХрд░реЗрдВ", "рдмрд╛рд╣рд░ рдирд┐рдХрд▓реЗрдВ", "рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ", "рдЪреИрдЯ рдмрдВрдж рдХрд░реЗрдВ", "рдЪреИрдЯ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ",
    "рдмрд╛рддрдЪреАрдд рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ", "рдмрд╛рддрдЪреАрдд рдмрдВрдж рдХрд░реЗрдВ", "рд╕рддреНрд░ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ", "рд▓реЙрдЧрдЖрдЙрдЯ", "рд╕рд╛рдЗрди рдЖрдЙрдЯ",
    // Emoji variations
    "ЁЯТм end chat", "ЁЯТм рдЪреИрдЯ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ", "ЁЯФЪ end", "ЁЯФЪ рд╕рдорд╛рдкреНрдд", "тЭМ close", "тЭМ рдмрдВрдж рдХрд░реЗрдВ"
  ];

  return endChatPhrases.some(phrase => endChatInput.includes(phrase.toLowerCase())) ||
    endChatInput === getMessage("endChat").toLowerCase();
}